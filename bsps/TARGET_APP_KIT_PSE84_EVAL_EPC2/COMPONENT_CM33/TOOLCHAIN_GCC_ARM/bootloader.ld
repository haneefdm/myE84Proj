/***************************************************************************//**
* \file bootloader.ld
* \version 1.0.0
*
* Linker file for the GNU C compiler.
*
* The main purpose of the linker script is to describe how the sections in the
* input files should be mapped into the output file, and to control the memory
* layout of the output file.
*
*
* \note The linker files included with the PDL template projects must be generic
* and handle all common use cases. Your project may not use every section
* defined in the linker files. In that case you may see warnings during the
* build process. In your project, you can simply comment out or remove the
* relevant code in the linker file.
*
********************************************************************************
* \copyright
* Copyright (c) (2020-2025), Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation.
* SPDX-License-Identifier: Apache-2.0
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/
/* Specify the output format for the linker script */
OUTPUT_FORMAT ("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
/* Search for libraries in the current directory */
SEARCH_DIR(.)
/* Specify the group of libraries to link against */
GROUP(-lgcc -lc -lnosys)
/* Define the entry point of the program, which is the reset handler */
ENTRY(S_Reset_Handler)


/* Define the stack size for the application */
/* To set stack size in application add makefile ldflags: -Wl,--defsym=APP_MSP_STACK_SIZE=<CUSTOM_VALUE> */
PROVIDE(__StackSize = DEFINED(APP_MSP_STACK_SIZE) ? APP_MSP_STACK_SIZE : 0x2000);

/* Include the device memory definitions generated by the Device Configurator */
INCLUDE cymem_gnu_CM33_0_S.ld

/* Linker script to place sections and symbol values. Should be used together
 * with other linker script that defines memory regions FLASH and RAM.
 * It references following symbols, which must be defined in code:
 *   Reset_Handler : Entry of reset handler
 *
 * It defines following symbols, which code can use without definition:
 *   __exidx_start
 *   __exidx_end
 *   __copy_table_start__
 *   __copy_table_end__
 *   __zero_table_start__
 *   __zero_table_end__
 *   __data_start__
 *   __preinit_array_start
 *   __preinit_array_end
 *   __init_array_start
 *   __init_array_end
 *   __fini_array_start
 *   __fini_array_end
 *   __data_end__
 *   __bss_start__
 *   __bss_end__
 *   __end__
 *   end
 *   __HeapLimit
 *   __StackLimit
 *   __StackTop
 *   __stack
 */

/* Device definitions */
VECTORS_ALIGNMENT = 0x400;

/* Compute the difference between S-AHB address and C-AHB address for
*  section m33s_code_S and m33_nsc_S. This value is used to correctly
*  copy code in the copy table.
*  This is needed because the code needs to be accessed from the C-AHB
*  address (faster, better performance) but since this is a read-only
*  address to perform the copy we need to specify the S-AHB address which
*  allows for writes as well.
*/
m33s_data_sel_S_Offset = ORIGIN(m33s_data_S) - ORIGIN(m33s_data_sel_S);

/* The size of the MCU boot header area at the start of main code region */
MCUBOOT_HEADER_SIZE = 0x400;
/* The size of the signature trail area at the end of main code region */
SIGNATURE_TRAIL_SIZE = 0x400;

/* Define the sections */
SECTIONS
{
    /* This section reserves a space for MCUBoot header */
    .mcu_boot_header(READONLY) : ALIGN(MCUBOOT_HEADER_SIZE)
    {
        . += MCUBOOT_HEADER_SIZE;
    } > bootloader_nvm_sel_S

    /* This section is intended to hold the main secure (S) application code for the Cortex-M33 */
    /* Performance-sensitive or critical functions that need to be executed in sram are manually excluded */
    .app_code_main : ALIGN(VECTORS_ALIGNMENT)
    {
        /* Keep the vector table */
        KEEP(*(.vectors))
        /* Keep initializers */
        KEEP(*(.init))
        /* Keep finalizers */
        KEEP(*(.fini))
        /* Static constructors */
        *crtbegin.*(.ctors)
        *crtbegin?.*(.ctors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .ctors)
        *(SORT(.ctors.*))
        *(.ctors)
        /* Static destructors and atexit() */
        *crtbegin.*(.dtors)
        *crtbegin?.*(.dtors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .dtors)
        *(SORT(.dtors.*))
        *(.dtors)

        . = ALIGN(4);

        /* Array of pointers to preinint functions */
        PROVIDE_HIDDEN(__preinit_array_start = .);

        KEEP(*(.preinit_array))

        PROVIDE_HIDDEN(__preinit_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to init functions */
        PROVIDE_HIDDEN(__init_array_start = .);

        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array))

        PROVIDE_HIDDEN(__init_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to finalizer functions */

        PROVIDE_HIDDEN(__fini_array_start = .);

        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array))

        PROVIDE_HIDDEN(__fini_array_end = .);

        /* Read only code (constants) */
        *(.rodata .rodata.* .constdata .constdata.* .conststring .conststring.*)
        /* Exclude certain files from this section as they will be placed in RAM */
        *(EXCLUDE_FILE(*cy_syslib.* *cy_syslib_ext.* *cy_smif.* *cy_smif_memslot.* *cy_smif_sfdp.* *cy_smif_hb_flash.* *mtb_hal_memoryspi.* *mtb_serial_memory.* *cy_gpio.*) .text*)
    } > bootloader_nvm_sel_S

    /* Exception tables for ARM architecture */
    .ARM.extab (READONLY): ALIGN(4)
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)
    } > bootloader_nvm_sel_S

    /* Exception index tables for ARM architecture */
    .ARM.exidx (READONLY): ALIGN(4)
    {
        __exidx_start = .;

        *(.ARM.exidx* .gnu.linkonce.armexidx.*)

        __exidx_end = .;
    } > bootloader_nvm_sel_S


    /* Define copying of data from flash memory to RAM during the startup */
    .copy.table (READONLY): ALIGN(4)
    {
        __copy_table_start__ = .;

        /* Initialized data in SRAM */
        LONG (LOADADDR(.data))                      /* From load address in ext flash */
        LONG (ADDR(.data))                          /* To run address in RAM */
        LONG (SIZEOF(.data)/4)                      /* Size in words */

        /* Performance-sensitive or critical functions that need to be executed in SRAM */
        LONG(LOADADDR(.app_code_ram))                       /* From load address in ext flash */
        LONG(ADDR(.app_code_ram) + m33s_data_sel_S_Offset)  /* To run address in RAM - using S-AHB for copying */
        LONG(SIZEOF(.app_code_ram)/4)                       /* Size in words */

        __copy_table_end__ = .;
    } > bootloader_nvm_sel_S

    /* Define zeroing of the uninitialized data section */
    .zero.table (READONLY): ALIGN(4)
    {
        __zero_table_start__ = .;

        LONG(__bss_start__)                       /* Start of the zero-initialized data section */
        LONG((__bss_end__ - __bss_start__)/4)     /* Size of the zero-initialized data section in words */

        __zero_table_end__ = .;
    } > bootloader_nvm_sel_S

    /* A section for the vector table */
    .ram_vectors (NOLOAD) : ALIGN(VECTORS_ALIGNMENT)
    {
        __ram_vectors_start__ = .;

        KEEP(*(.ram_vectors))

        __ram_vectors_end__ = .;
    } > m33s_data_S

    /* A section for performance-sensitive or critical functions that need to be executed in SRAM */
    .app_code_ram (ORIGIN(m33s_data_sel_S) + (__ram_vectors_end__ - ORIGIN(m33s_data_S))): ALIGN(4)
    {
        __cy_sram0_code_vma_start__ = .;

        KEEP(*(.cy_sram_code))
        KEEP(*(.cy_ramfunc))
        KEEP(*(.text.cy_os_common))
        *cy_syslib_ext.*(.text*)
        *cy_syslib.*(.text*)
        *cy_smif.*(.text*)
        *cy_smif_memslot.*(.text*)
        *cy_smif_sfdp.*(.text*)
        *cy_smif_hb_flash.*(.text*)
        *mtb_hal_memoryspi.*(.text*)
        *mtb_serial_memory.*(.text*)
        *cy_gpio.*(.text*)

        . = ALIGN(4);

        __cy_sram0_code_vma_end__ = .;
    } > m33s_data_sel_S AT > bootloader_nvm_sel_S

    /* A section for initialized data memory */
    .data (ORIGIN(m33s_data_S) + (__cy_sram0_code_vma_end__ - ORIGIN(m33s_data_sel_S))): ALIGN(4)
    {
        __data_start__ = .;

        *(.data*)
        KEEP(*(.jcr*))

        . = ALIGN(4);

        __data_end__ = .;
    } > m33s_data_S AT > bootloader_nvm_sel_S

    /* A section for non-initialized data memory */
    .bss(NOLOAD) : ALIGN(4)
    {
        __bss_start__ = .;

        *(.bss*)
        *(COMMON)
        *(.cy_sharedmem_sec)
        *(.cy_sharedmem)

        . = ALIGN(4);

        __bss_end__ = .;
    } > m33s_data_S

    /* A section for variables that should not be initialized during the device startup */
    .noinit (NOLOAD) :
    {
        KEEP(*(.noinit))
    } > m33s_data_S

    /* A section for the heap memory */
    .heap(NOLOAD) : ALIGN(8)
    {
        __HeapBase = .;
        __end__ = .;
        end = __end__;

        KEEP(*(.heap*))

        . = ALIGN(8);
        . = ORIGIN(m33s_data_S) + LENGTH(m33s_data_S) - __StackSize;
        __HeapLimit = .;
    } > m33s_data_S

    __StackTop = ORIGIN(m33s_data_S) + LENGTH(m33s_data_S);
    __StackLimit = __StackTop - __StackSize;
    PROVIDE(__stack = __StackTop);

    /* Check if data + stack exceeds RAM limit still allows for Heap to be placed */
    ASSERT(
        __HeapLimit  >= __HeapBase,
        "Error: RAM region overflowed with stack. Ensure that the stack size is within the available RAM."
    )

    /* Reserve a trail space for the signature */
    .cy_signature(NOLOAD) : ALIGN(SIGNATURE_TRAIL_SIZE)
    {
        __signature_start = .;
        . += SIGNATURE_TRAIL_SIZE;
        __signature_end = .;
    } > bootloader_nvm_sel_S
}
