/***************************************************************************//**
* \file pse84_ns_cm33.ld
* \version 1.0.0
*
* Linker file for the GNU C compiler.
*
* The main purpose of the linker script is to describe how the sections in the
* input files should be mapped into the output file, and to control the memory
* layout of the output file.
*
*
* \note The linker files included with the PDL template projects must be generic
* and handle all common use cases. Your project may not use every section
* defined in the linker files. In that case you may see warnings during the
* build process. In your project, you can simply comment out or remove the
* relevant code in the linker file.
*
********************************************************************************
* \copyright
* Copyright (c) (2020-2025), Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation.
* SPDX-License-Identifier: Apache-2.0
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/
/* Specify the output format for the linker script */
OUTPUT_FORMAT ("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
/* Search for libraries in the current directory */
SEARCH_DIR(.)
/* Specify the group of libraries to link against */
GROUP(-lgcc -lc -lnosys)
/* Define the entry point of the program, which is the reset handler */
ENTRY(Reset_Handler)

/* Define the stack size for the application */
/* To set stack size in application add makefile ldflags: -Wl,--defsym=APP_MSP_STACK_SIZE=<CUSTOM_VALUE> */
PROVIDE(__StackSize = DEFINED(APP_MSP_STACK_SIZE) ? APP_MSP_STACK_SIZE : 0x1000);

/* Include the device memory definitions generated by the Device Configurator */
INCLUDE cymem_gnu_CM33_0.ld

/* Linker script to place sections and symbol values. Should be used together
 * with other linker script that defines memory regions FLASH and RAM.
 * It references following symbols, which must be defined in code:
 *   Reset_Handler : Entry of reset handler
 *
 * It defines following symbols, which code can use without definition:
 *   __exidx_start
 *   __exidx_end
 *   __copy_table_start__
 *   __copy_table_end__
 *   __zero_table_start__
 *   __zero_table_end__
 *   __data_start__
 *   __preinit_array_start
 *   __preinit_array_end
 *   __init_array_start
 *   __init_array_end
 *   __fini_array_start
 *   __fini_array_end
 *   __data_end__
 *   __bss_start__
 *   __bss_end__
 *   __end__
 *   end
 *   __HeapLimit
 *   __StackLimit
 *   __StackTop
 *   __stack
 */

/* Device definitions */
VECTORS_ALIGNMENT = 0x400;

/* Compute the difference between C-AHB address and S-AHB address for
*  section m33_code. This value is used to correctly copy code in the
*  copy table. This is needed because the code needs to be accessed from
*  the C-AHB address (faster, better performance) but since this is a read-only
*  address to perform the copy we need to specify the S-AHB address which
*  allows for writes as well.
*/
m33_code_sel_Offset = ORIGIN(m33_code) - ORIGIN(m33_code_sel);

/* The size of the MCU boot header area at the start of main code region */
MCUBOOT_HEADER_SIZE = 0x400;

/* Define the sections */
SECTIONS
{
    /* This section reserves a space for MCUBoot header */
    .mcu_boot_header(READONLY) : ALIGN(MCUBOOT_HEADER_SIZE)
    {
        . += MCUBOOT_HEADER_SIZE;
    } > m33_nvm_sel

    /* This section is intended to hold the main non-secure (NS) application code for the Cortex-M33 */
    /* Performance-sensitive or critical functions that need to be executed in sram are manually excluded */
    .app_code_main : ALIGN(VECTORS_ALIGNMENT)
    {
        /* Keep the vector table */
        KEEP(*(.vectors))
        /* Keep initializers */
        KEEP(*(.init))
        /* Keep finalizers */
        KEEP(*(.fini))
        /* Static constructors */
        *crtbegin.*(.ctors)
        *crtbegin?.*(.ctors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .ctors)
        *(SORT(.ctors.*))
        *(.ctors)
        /* Static destructors and atexit() */
        *crtbegin.*(.dtors)
        *crtbegin?.*(.dtors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .dtors)
        *(SORT(.dtors.*))
        *(.dtors)

        . = ALIGN(4);

        /* Array of pointers to preinint functions */
        PROVIDE_HIDDEN(__preinit_array_start = .);

        KEEP(*(.preinit_array))

        PROVIDE_HIDDEN(__preinit_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to init functions */
        PROVIDE_HIDDEN(__init_array_start = .);

        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array))

        PROVIDE_HIDDEN(__init_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to finalizer functions */

        PROVIDE_HIDDEN(__fini_array_start = .);

        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array))

        PROVIDE_HIDDEN(__fini_array_end = .);

        /* Read only code (constants) */
        *(.rodata .rodata.* .constdata .constdata.* .conststring .conststring.*)
        /* Exclude certain files from this section as they will be placed in RAM */
        *(EXCLUDE_FILE(*cy_syslib.* *cy_syslib_ext.* *cy_smif.* *cy_smif_memnum.* *cy_smif_memslot.* *cy_smif_sfdp.* *cy_smif_hb_flash.* *mtb_hal_memoryspi.* *mtb_serial_memory.* *freertos/Source*.* *cy_clib_support*.* *cy_mutex_pool*.* *cy_time.* *cyabs_*.* *cy_worker_thread.* *cmsis*.*) .text*)

    } > m33_nvm_sel

    /* Exception tables for ARM architecture */
    .ARM.extab (READONLY): ALIGN(4)
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)

    } > m33_nvm_sel

    /* Exception index tables for ARM architecture */
    .ARM.exidx (READONLY): ALIGN(4)
    {
        __exidx_start = .;

        *(.ARM.exidx* .gnu.linkonce.armexidx.*)

        __exidx_end = .;

    } > m33_nvm_sel

    /* Define copying of data from flash memory to RAM during the startup */
    .copy.table (READONLY): ALIGN(4)
    {
        __copy_table_start__ = .;

        /* Initialized data in SRAM */
        LONG (LOADADDR(.data))                              /* From load address in ext flash  */
        LONG (ADDR(.data))                                  /* To run address in RAM  */
        LONG (SIZEOF(.data)/4)                              /* Size in words */

        /* Performance-sensitive or critical functions that need to be executed in SRAM */
        LONG(LOADADDR(.app_code_ram))                         /* From load address in ext flash */
        LONG(ADDR(.app_code_ram) + m33_code_sel_Offset)       /* To run address in RAM - using S-AHB for copying */
        LONG(SIZEOF(.app_code_ram)/4)                         /* Size in words */

        __copy_table_end__ = .;

    } > m33_nvm_sel

    /* Define zeroing of the uninitialized data section */
    .zero.table (READONLY): ALIGN(4)
    {
        __zero_table_start__ = .;

        LONG(__bss_start__)                       /* Start of the zero-initialized data section */
        LONG((__bss_end__ - __bss_start__)/4)     /* Size of the zero-initialized data section in words */

        __zero_table_end__ = .;

    } > m33_nvm_sel

    /* A section for performance-sensitive or critical functions that need to be executed in SRAM */
    .app_code_ram : ALIGN(4)
    {
        KEEP(*(.cy_sram_code))
        KEEP(*(.cy_ramfunc))
        KEEP(*(.text.cy_os_common))
        *cy_syslib_ext.*(.text*)
        *cy_syslib.*(.text*)
        *cy_smif.*(.text*)
        *cy_smif_memnum.*(.text*)
        *cy_smif_memslot.*(.text*)
        *cy_smif_sfdp.*(.text*)
        *cy_smif_hb_flash.*(.text*)
        *mtb_hal_memoryspi.*(.text*)
        *mtb_serial_memory.*(.text*)
        *freertos/Source*.*(.text*)
        *cy_clib_support*.*(.text*)
        *cy_mutex_pool*.*(.text*)
        *cy_time.*(.text*)
        *cyabs_*.*(.text*)
        *cy_worker_thread.*(.text*)
        *cmsis*.*(.text*)

        . = ALIGN(4);
    } > m33_code_sel AT > m33_nvm_sel


    /* A section for the vector table */
    .ram_vectors (NOLOAD) : ALIGN(VECTORS_ALIGNMENT)
    {
        KEEP(*(.ram_vectors))
    } > m33_data

    /* A section for initialized data memory */
    .data : ALIGN(4)
    {
        __data_start__ = .;

        *(.data*)
        KEEP(*(.jcr*))

        . = ALIGN(4);

        __data_end__ = .;
    } > m33_data AT > m33_nvm_sel

    /* A section for non-initialized data memory */
    .bss(NOLOAD) : ALIGN(4)
    {
        __bss_start__ = .;

        *(.bss*)
        *(COMMON)

        . = ALIGN(4);

        __bss_end__ = .;
    } > m33_data

    /* A section for variables that should not be initialized during the device startup */
    .noinit (NOLOAD) :
    {
        KEEP(*(.noinit))
    } > m33_data

    /* A section for the heap memory */
    .heap(NOLOAD) : ALIGN(8)
    {
        __HeapBase = .;
        __end__ = .;
        end = __end__;

        KEEP(*(.heap*))

        . = ORIGIN(m33_data) + LENGTH(m33_data) - __StackSize;
        __HeapLimit = .;
    } > m33_data

    /* Define stack top, and stack limit */
    __StackTop = ORIGIN(m33_data) + LENGTH(m33_data);
    __StackLimit = __StackTop - __StackSize;
    PROVIDE(__stack = __StackTop);

    /* Check if data + stack still allows for Heap to be placed */
    ASSERT(
        __HeapLimit > __HeapBase,
        "Error: RAM region overflowed with stack. Ensure that the stack size is within the available RAM."
    )

    /* A section for shared RAM memory where only the Cortex-M33 Non Secure can allocate data but all cores can access */
    .cy_sharedmem(NOLOAD) : ALIGN(4)
    {
        KEEP(*(.cy_sharedmem))

        . = ALIGN(4);
    } > m33_allocatable_shared

    /* A section for shared SOC memory */
    .cy_shared_socmem (NOLOAD) : ALIGN(4)
    {
        KEEP(*(.cy_shared_socmem))

        . = ALIGN(4);
    } > m33_m55_shared


    /* A section for the GPU buffer */
    .cy_gpu_buf(NOLOAD) :
    {
        KEEP(*(.cy_gpu_buf))
    }  > gfx_mem


    /* Reserve a trail space for the signature for the bootloader - do not place any code here */
    .cy_trailer(NOLOAD) :
    {
    } > m33_trailer_sel

}
