/***************************************************************************//**
* \file pse84_ns_cm55.ld
* \version 1.0.0
*
* Linker file for the LLVM C compiler.
*
* The main purpose of the linker script is to describe how the sections in the
* input files should be mapped into the output file, and to control the memory
* layout of the output file.
*
*
* \note The linker files included with the PDL template projects must be generic
* and handle all common use cases. Your project may not use every section
* defined in the linker files. In that case you may see warnings during the
* build process. In your project, you can simply comment out or remove the
* relevant code in the linker file.
*
********************************************************************************
* \copyright
* Copyright (c) (2025), Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation.
* SPDX-License-Identifier: Apache-2.0
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/
/* Specify the output format for the linker script */
OUTPUT_FORMAT ("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
/* Search for libraries in the current directory */
SEARCH_DIR(.)
/* Specify the group of libraries to link against */
GROUP(-lc -lc++ -lcrt0 -lsemihost)
GROUP(libc.a libm.a libcrt0.a libsemihost.a)
/* Define the entry point of the program, which is the reset handler */
ENTRY(Reset_Handler)

/* Define the stack size for the application */
/* To set stack size in application add makefile ldflags: -Wl,--defsym=APP_MSP_STACK_SIZE=<CUSTOM_VALUE> */
__stack_size = DEFINED(APP_MSP_STACK_SIZE) ? APP_MSP_STACK_SIZE : 0x00001000;

/* Include the device memory definitions generated by the Device Configurator */
INCLUDE cymem_gnu_CM55_0.ld

/* Linker script to place sections and symbol values. Should be used together
 * with other linker script that defines memory regions FLASH and RAM.
 * It references following symbols, which must be defined in code:
 *   Reset_Handler : Entry of reset handler
 *
 * It defines following symbols, which code can use without definition:
 *   __exidx_start
 *   __exidx_end
 *   __copy_table_start__
 *   __copy_table_end__
 *   __zero_table_start__
 *   __zero_table_end__
 *   __data_start__
 *   __preinit_array_start
 *   __preinit_array_end
 *   __init_array_start
 *   __init_array_end
 *   __fini_array_start
 *   __fini_array_end
 *   __data_end__
 *   __bss_start__
 *   __bss_end__
 *   __end__
 *   end
 *   __heap_end
 *   __stack_limit
 *   __stack
 */

/* Device definitions */
VECTORS_ALIGNMENT = 0x400;

/* The size of the MCU boot header area at the start of main code region */
MCUBOOT_HEADER_SIZE = 0x400;

/* Define the sections */
SECTIONS
{
    /* This section reserves a space for MCUBoot header */
    .mcu_boot_header(NOLOAD) : ALIGN(MCUBOOT_HEADER_SIZE)
    {
        . += MCUBOOT_HEADER_SIZE;
    } > m55_nvm_sel

    /* This section is intended to hold the main application code for the Cortex-M55 */
    /* Performance-sensitive or critical functions that need to be executed in sram are manually excluded */
    .app_code_main : ALIGN(VECTORS_ALIGNMENT)
    {
        __text_begin = .;
        __Vectors = . ;
        /* Keep the vector table */
        KEEP(*(.vectors))

        . = ALIGN(4);

        __Vectors_End = .;

        /* Keep initializers */
        KEEP(*(.init))
        /* Keep finalizers */
        KEEP(*(.fini))
        KEEP(*(__lcxx_override))
        /* Static constructors */
        *crtbegin.*(.ctors)
        *crtbegin?.*(.ctors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .ctors)
        *(SORT(.ctors.*))
        *(.ctors)
        /* Static destructors and atexit() */
        *crtbegin.*(.dtors)
        *crtbegin?.*(.dtors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .dtors)
        *(SORT(.dtors.*))
        *(.dtors)
        /* Read only code (constants) */
        *(.rodata .rodata.* .constdata .constdata.* .conststring .conststring.*)
        /* Exclude certain files from this section as they will be placed in RAM */
        *(EXCLUDE_FILE(*cy_syslib.* *cy_syslib_ext.* *cy_smif.* *cy_smif_memnum.* *cy_smif_memslot.* *cy_smif_sfdp.* *cy_smif_hb_flash.* *cyhal_qspi.* *mtb_hal_memoryspi.* *mtb_serial_memory.* *freertos/Source*.* *cy_clib_support*.* *cy_mutex_pool*.* *cy_time.* *cyabs_*.* *cy_worker_thread.* *cmsis*.*) .text*)

        . = ALIGN(4);

        __text_end = .;
    } > m55_nvm_sel

    /* Exception tables for ARM architecture */
    .ARM.extab : ALIGN(4)
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)
    } > m55_nvm_sel

    /* Exception index tables for ARM architecture */
    .ARM.exidx : ALIGN(4)
    {
        __exidx_start = .;

        *(.ARM.exidx* .gnu.linkonce.armexidx.*)

        __exidx_end = .;
    } > m55_nvm_sel

    /* Define copying of data from flash memory to RAM during the startup */
    .copy.table : ALIGN(4)
    {
        __copy_table_start__ = .;

        /* Initialized data in DTCM */
        LONG(LOADADDR(.data))       /* From load address in ext flash  */
        LONG(ADDR(.data))           /* To run address in DTCM  */
        LONG(SIZEOF(.data)/4)       /* Size in words */

        /* Initialized data in SOC memory */
        LONG(LOADADDR(.cy_socmem_data))     /* From load address in ext flash  */
        LONG(ADDR(.cy_socmem_data))         /* To run address in SOCMEM  */
        LONG(SIZEOF(.cy_socmem_data)/4)     /* Size in words */

        /* Code in ITCM */
        LONG (LOADADDR(.app_code_itcm)) /* From load address in ext flash  */
        LONG (ADDR(.app_code_itcm))     /* To run address in ITCM  */
        LONG (SIZEOF(.app_code_itcm)/4) /* Size in words */

        /* Code in SOC memory */
        LONG (LOADADDR(.app_code_socmem)) /* From load address in ext flash  */
        LONG (ADDR(.app_code_socmem))     /* To run address in SOCMEM  */
        LONG (SIZEOF(.app_code_socmem)/4) /* Size in words */

        __copy_table_end__ = .;
    } > m55_nvm_sel

    /* Define zeroing of the uninitialized data section */
    .zero.table : ALIGN(4)
    {
        __zero_table_start__ = .;

        LONG(__bss_start__)                       /* Start of the zero-initialized data section */
        LONG((__bss_end__ - __bss_start__)/4)     /* Size of the zero-initialized data section in words */

        __zero_table_end__ = .;
    } > m55_nvm_sel

    /* A section for performance-sensitive or critical functions that need to be executed in ITCM */
    .app_code_itcm : ALIGN(16)
    {
        /* Reserving the first 16 bytes to avoid debug symbols (that have default address 0x0) to be confused with actual code  */
        . += 16;
        KEEP(*(.cy_itcm))
        KEEP(*(.cy_sram_code))
        KEEP(*(.cy_ramfunc))
        *cy_syslib_ext.*(.text*)
        *cy_syslib.*(.text*)
        *cy_smif.*(.text*)
        *cy_smif_memnum.*(.text*)
        *cy_smif_memslot.*(.text*)
        *cy_smif_sfdp.*(.text*)
        *cy_smif_hb_flash.*(.text*)
        *mtb_hal_memoryspi.*(.text*)
        *mtb_serial_memory.*(.text*)
        *freertos/Source*.*(.text*)
        *cy_clib_support*.*(.text*)
        *cy_mutex_pool*.*(.text*)
        *cy_time.*(.text*)
        *cyabs_*.*(.text*)
        *cy_worker_thread.*(.text*)
        *cmsis*.*(.text*)

        . = ALIGN(4);
    } > m55_code_INTERNAL AT > m55_nvm_sel

    /* A section for the vector table */
    .ram_vectors (NOLOAD) : ALIGN(VECTORS_ALIGNMENT)
    {
        __ram_vectors_start__ = .;

        KEEP(*(.ram_vectors))

        __ram_vectors_end__ = .;
    } > m55_code_INTERNAL

    /* A section for less performance-sensitive or critical functions that might be executed in SOC memory */
    .app_code_socmem : ALIGN(4)
    {
        KEEP(*(.cy_socmem_code))

        . = ALIGN(4);
    }  > m55_code_secondary AT > m55_nvm_sel

    /* A section for initialized data memory */
    .data : ALIGN(4)
    {
        __data_start__ = .;

        *(vtable)
        *(.data*)

        . = ALIGN(4);

        /* Array of pointers to preinit functions */
        PROVIDE_HIDDEN (__preinit_array_start = .);

        KEEP(*(.preinit_array))

        PROVIDE_HIDDEN (__preinit_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to init functions */
        PROVIDE_HIDDEN (__init_array_start = .);

        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array))

        PROVIDE_HIDDEN (__init_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to finalizer functions */

        PROVIDE_HIDDEN (__fini_array_start = .);

        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array))

        PROVIDE_HIDDEN (__fini_array_end = .);

        KEEP(*(.jcr*))

        . = ALIGN(4);

        KEEP(*(.cy_dtcm))

        . = ALIGN(4);

        __data_end__ = .;
    } > m55_data_INTERNAL AT > m55_nvm_sel

    /* Read-only after relocation: Writable during relocation, read-only afterward. */
    .data.rel.ro : ALIGN(16)
    {
        *(.data.rel.ro .data.rel.ro.*)
        *(.got)         /* Include .got section here */
        *(.got.plt)     /* Include .got.plt section here */
    } > m55_data_INTERNAL AT > m55_nvm_sel

    /* Provide value for the variable requied by crt0 library */
    PROVIDE(__bss_start = __bss_start__);
    PROVIDE(__bss_end = __bss_end__);
    PROVIDE(__bss_size = __bss_end - __bss_start);
    PROVIDE(__data_start = __data_start__);
    PROVIDE(__data_end = __data_end__);
    PROVIDE(__data_size = __data_end - __data_start );
    PROVIDE(__data_source = LOADADDR(.data));
    PROVIDE(__data_source_end = LOADADDR(.data) + SIZEOF(.data));
    PROVIDE(__data_source_size = SIZEOF(.data));

    /* Thread local storage initialized data. */
    .tdata : ALIGN(__tls_align)
    {
        *(.tdata .tdata.* .gnu.linkonce.td.*)
    } > m33_m55_shared AT > m55_nvm_sel :ram_init
    PROVIDE(__tls_base = ADDR(.tdata));
    PROVIDE(__tdata_start = ADDR(.tdata));
    PROVIDE(__tdata_end = ADDR(.tdata) + SIZEOF(.tdata));
    PROVIDE(__tdata_source = LOADADDR(.tdata));
    PROVIDE(__tdata_source_end = LOADADDR(.tdata) + SIZEOF(.tdata));
    PROVIDE(__tdata_size = SIZEOF(.tdata) );

    PROVIDE(__edata = __data_end);
    PROVIDE(_edata = __data_end);
    PROVIDE(edata = __data_end);

    /* Thread local storage for non-initialized data. */
    .tbss (NOLOAD) : {
        *(.tbss .tbss.* .gnu.linkonce.tb.*)
        *(.tcommon)
    } > m33_m55_shared AT > m33_m55_shared :tls :ram
    PROVIDE(__bss_start = ADDR(.tbss));
    PROVIDE(__tbss_start = ADDR(.tbss));
    PROVIDE(__tbss_end = ADDR(.tbss) + SIZEOF(.tbss));
    PROVIDE(__tbss_offset = ADDR(.tbss) - ADDR(.tdata));
    PROVIDE(__tbss_size = SIZEOF(.tbss));
    PROVIDE(__tls_end = __tbss_end);
    PROVIDE(__tls_size = __tls_end - __tls_base );
    PROVIDE(__tls_align = MAX(ALIGNOF(.tdata), ALIGNOF(.tbss)) );
    PROVIDE(__tls_size_align = (__tls_size + __tls_align - 1) & ~(__tls_align - 1));
    PROVIDE(__arm32_tls_tcb_offset = MAX(8, __tls_align) );
    PROVIDE(__arm64_tls_tcb_offset = MAX(16, __tls_align) );

    /* A section for variables that should not be initialized during the device startup */
    .noinit (NOLOAD) : ALIGN(8)
    {
        __noinit_start__ = .;

        KEEP(*(.noinit))
        /* LLVM specific workaround to include input section "__DATA, __noinit" */
        KEEP(*(*__noinit))

        . = ALIGN(4);

        __noinit_end__ = .;
    } > m55_data_INTERNAL

    /* A section for non-initialized data memory */
    .bss(NOLOAD) : ALIGN(4)
    {
        __bss_start__ = .;

        *(.bss*)
        *(COMMON)

        . = ALIGN(4);

        __bss_end__ = .;
    } > m55_data_INTERNAL

    /* Global Offset Table: Stores addresses for position-independent code. */
    .got (NOLOAD) :
    {
        . = ALIGN(16);  /* Align to cache line boundary */
        *(.got)
        *(.got.plt)
    } > m55_data_INTERNAL

    __stack = ORIGIN(m55_data_INTERNAL) + LENGTH(m55_data_INTERNAL);
    __stack_limit = __stack - __stack_size;

    /* Check if .data + .noinit + .bss + stack exceeds RAM limit in region m55_data_INTERNAL */
    ASSERT(
      __stack_limit >= __bss_end__,
      "Error: m55_data_INTERNAL region overflowed with stack. Ensure that the stack size is within the available RAM."
    )

    /* A section for SOC memory data */
    .cy_socmem_data : ALIGN(4)
    {
        KEEP(*(.cy_socmem_data))

        . = ALIGN(4);
    }  > m55_data_secondary AT > m55_nvm_sel

    /* A section for the heap memory */
    .heap(NOLOAD) : ALIGN(8)
    {
        __heap_start = .;
        __end__ = .;
        end = __end__;

        KEEP(*(.heap*))

        . = ORIGIN(m55_data_secondary) + LENGTH(m55_data_secondary);
        __heap_end = .;
    } > m55_data_secondary

    /* A section for reserved SOC memory */
    .reserved_socmem(NOLOAD) :
    {
        . = ORIGIN(m33_m55_shared) + LENGTH(m33_m55_shared); /* reserved SOC memory */
    } > m33_m55_shared

    /* A section for the GPU buffer */
    .cy_gpu_buf(NOLOAD) :
    {
        KEEP(*(.cy_gpu_buf))
    } > gfx_mem

    /* A section for shared RAM memory  where only the Cortex-M55 can allocate data but all cores can access */
    .cy_sharedmem(NOLOAD) : ALIGN(4)
    {
        KEEP(*(.cy_sharedmem))
        /* LLVM specific workaround to include input section "__DATA, .cy_sharedmem" */
        KEEP(*(*.cy_sharedmem))
        . = ALIGN(4);
    } > m55_allocatable_shared

    /* Reserve a trail space for the signature for the bootloader - do not place any code here */
    .cy_trailer(NOLOAD) :
    {
    } > m55_trailer_sel

    /* Throw away C++ exception handling information */
        /DISCARD/ : {
        *(.note .note.*)
        *(.eh_frame .eh_frame.*)
        *(.ARM.extab* .gnu.linkonce.armextab.*)
        *(.ARM.exidx*)
    }
}
